## ResNet50
```
import subprocess
import sys

# è‡ªåŠ¨å®‰è£…ä¾èµ–
def install_packages():
    packages = ["torch", "torchvision", "pillow", "pandas", "openpyxl", "requests"]
    for pkg in packages:
        try:
            __import__(pkg)
        except ImportError:
            subprocess.check_call([sys.executable, "-m", "pip", "install", pkg])

install_packages()

# === å¯¼å…¥ä¾èµ– ===
import os
import shutil
import torch
from torchvision import models, transforms
from PIL import Image
import pandas as pd
from collections import defaultdict
import requests

# === å›¾åƒé¢„å¤„ç†ï¼ˆImageNetï¼‰===
transform = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(
        mean=[0.485, 0.456, 0.406],
        std=[0.229, 0.224, 0.225]
    )
])

# === åŠ è½½ ResNet50 æ¨¡å‹ ===
model = models.resnet50(pretrained=True)
model.eval()

# === åŠ è½½ç±»åˆ«æ ‡ç­¾ ===
# https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt

LABELS_PATH = r"g:\Dataset\Image\COCO_Annotations\imagenet_classes.txt"
with open(LABELS_PATH, "r", encoding="utf-8") as f:
    labels = f.read().strip().split('\n')


# === å•å¼ å›¾åƒåˆ†ç±» ===
def classify_image(image_path):
    image = Image.open(image_path).convert("RGB")
    input_tensor = transform(image).unsqueeze(0)
    with torch.no_grad():
        output = model(input_tensor)
        probs = torch.nn.functional.softmax(output[0], dim=0)
        top1_prob, top1_class = torch.topk(probs, 1)
    return labels[top1_class.item()], top1_prob.item()

# === åˆ†ç±»ä¸»æµç¨‹ ===
def organize_images_by_class(src_dir, dst_dir):
    records = []
    class_counts = defaultdict(int)

    for fname in os.listdir(src_dir):
        if not fname.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp', '.png')):
            continue

        img_path = os.path.join(src_dir, fname)
        predicted_class, prob = classify_image(img_path)
        class_folder = os.path.join(dst_dir, predicted_class)
        os.makedirs(class_folder, exist_ok=True)

        shutil.copy(img_path, os.path.join(class_folder, fname))
        records.append({
            "æ–‡ä»¶å": fname,
            "é¢„æµ‹ç±»åˆ«": predicted_class,
            "ç½®ä¿¡åº¦": round(prob, 4)
        })
        class_counts[predicted_class] += 1

    # ä¿å­˜ç»“æœåˆ° Excel
    df = pd.DataFrame(records)
    count_df = pd.DataFrame([
        {"é¢„æµ‹ç±»åˆ«": k, "å›¾ç‰‡æ•°é‡": v}
        for k, v in sorted(class_counts.items(), key=lambda x: -x[1])
    ])
    output_excel = os.path.join(dst_dir, "result.xlsx")
    with pd.ExcelWriter(output_excel) as writer:
        df.to_excel(writer, index=False, sheet_name="åˆ†ç±»ç»“æœ")
        count_df.to_excel(writer, index=False, sheet_name="ç±»åˆ«æ±‡æ€»")

    print(f"\nâœ… åˆ†ç±»å®Œæˆï¼Œç»“æœä¿å­˜åœ¨ {output_excel}")
    print(f"ğŸ“ åˆ†ç±»åçš„æ–‡ä»¶ä½äº: {dst_dir}")

# === å‘½ä»¤è¡Œå…¥å£ ===
if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="å¯¹å›¾åƒè¿›è¡Œåˆ†ç±»å¹¶å¤åˆ¶åˆ°å¯¹åº”ç±»åˆ«ç›®å½•")
    parser.add_argument("--src", default=r"G:\Dataset\Image\images", help="åŸå§‹å›¾åƒè·¯å¾„")
    parser.add_argument("--dst", default=r"G:\Dataset\Image\tag", help="åˆ†ç±»ç»“æœä¿å­˜è·¯å¾„")
    args = parser.parse_args()

    organize_images_by_class(args.src, args.dst)
```